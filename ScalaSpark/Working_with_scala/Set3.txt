#Set 3

Pair RDD: data > (K,V) Ex: This is my content---> This, This is my content.
-groupBy
-reduceBY
-groupByKey
-reduceByKey
-countByKey
-zip/sub/union/join/...


val x = sc.textFile("/sampledata/abc1.txt")
val paira = x.map(n => (n.split(" ")(0),n))
paira.collect()
val groupeda = paira.groupByKey()
groupeda.collect()
groupeda.keys.take(10).foreach(println)
groupeda.values.take(10).foreach(println)

val y = sc.textFile("/sampledata/abc2.txt")
val pairb = y.map(n => (n.split(" ")(0),n))
pairb.collect()
val groupedb = pairb.groupByKey()
groupedb.collect()
groupedb.keys.take(10).foreach(println)
groupedb.values.take(10).foreach(println)

paira.sortByKey().take(20).foreach(println)
pairb.sortByKey().take(20).foreach(println)
paira.sortByKey(false).take(20).foreach(println)

x = sc.textFile("/sampledata/abc1.txt")
val result = x.map(n => n.split(" ")).sortBy(n => n(0))
OR
val result = x.map(n => n.split(" ")).sortBy(n => n(0),false)
result.collect()

paira.countByKey().take(5).foreach(println)
pairb.countByKey().take(5).foreach(println)

#this may not be useful here as we cant reduce the content based on key. 
val reduced = paira.reduceByKey(_+_)

val union_data = paira.union(pairb)
union_data.collect()
union_data.getNumPartitions
paira.getNumPartitions
pairb.getNumPartitions

pairb.subtract(paira).collect()
pairb.intersection(paira).collect()
paira.zip(pairb)
paira.join(pairb).collect()

=====================================
